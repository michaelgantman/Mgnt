<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_311) on Thu Jan 06 15:21:39 EET 2022 -->
<title>com.mgnt.lifecycle.management</title>
<meta name="date" content="2022-01-06">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="com.mgnt.lifecycle.management";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Package</li>
<li><a href="../../../../com/mgnt/lifecycle/management/backgroundrunner/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/mgnt/lifecycle/management/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;com.mgnt.lifecycle.management</h1>
<div class="docSummary">
<div class="block">This package contains some small infrastructure that simplifies and automates working with Factories that provide
 concrete implementations of an Interface.</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer">
<ul class="blockList">
<li class="blockList">
<table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation">
<caption><span>Class Summary</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Class</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management">BaseEntity</a>&lt;I&gt;</td>
<td class="colLast">
<div class="block">This is the base class for any set of classes that self-insert themselves into a Factory upon instantiation
 The way it works that a user will need to create an Interface and an abstract class implementing this Interface.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="../../../../com/mgnt/lifecycle/management/BaseEntityFactory.html" title="class in com.mgnt.lifecycle.management">BaseEntityFactory</a>&lt;I&gt;</td>
<td class="colLast">
<div class="block">This is the parent factory class for all the factories.</div>
</td>
</tr>
</tbody>
</table>
</li>
</ul>
<a name="package.description">
<!--   -->
</a>
<h2 title="Package com.mgnt.lifecycle.management Description">Package com.mgnt.lifecycle.management Description</h2>
<div class="block">This package contains some small infrastructure that simplifies and automates working with Factories that provide
 concrete implementations of an Interface. The package contains just 2 classes:
 <a href="../../../../com/mgnt/lifecycle/management/BaseEntityFactory.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntityFactory</code></a> and <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntity</code></a>. In short
 what this infrastructure does is that if you create a factory that extends
 <a href="../../../../com/mgnt/lifecycle/management/BaseEntityFactory.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntityFactory</code></a> and some Interface with all its concrete implementations
 extending <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntity</code></a> then each your concrete implementation class instances will be
 automatically inserted into your factory. You won't have to worry about how and when to populate your factory. The
 infrastructure will do it for you when the constructor of your concrete implementation class is invoked. So all you
 will have to do is to create any number of concrete implementation classes and make sure that for each one constructor
 is invoked. After that you can use your factory to get any of your concrete implementation classes anywhere in your code.
 This is short explanation. There are few more details but not that many.

 <br><br><p>
 Lets show it with an example. This infrastructure has Package <b><code>com.mgnt.lifecycle.management.example</code></b>
 that has some sub-packages that contains source code example that demonstrate how this infrastructure is used. So in
 this javadoc the same classes will be used. Please see the source code of that package to get all the details.
 Say you have an Interface called
 <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatter.html" title="interface in com.mgnt.lifecycle.management.example"><code>InfoFormatter</code></a> that has a single method
 <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatter.html#formatMessage-java.lang.String-"><code>InfoFormatter.formatMessage(java.lang.String)</code></a>. Obviously this method
 takes some text and formats it according some logic that would be implemented in each concrete implementation.
 <p>
 Next we need to create a factory for our concrete implementations. So we have a factory class
 <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatterFactory.html" title="class in com.mgnt.lifecycle.management.example"><code>InfoFormatterFactory</code></a> that extends
 <a href="../../../../com/mgnt/lifecycle/management/BaseEntityFactory.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntityFactory</code></a> This class look like this:
 <code><br><br>
 package com.mgnt.lifecycle.management.example;<br>

 import com.mgnt.lifecycle.management.BaseEntityFactory;<br>
 import java.util.Collection;<br>
<br>
 public class InfoFormatterFactory extends BaseEntityFactory&lt;InfoFormatter&gt; {<br>
     &#x00A0;&#x00A0;private static InfoFormatterFactory FACTORY = new InfoFormatterFactory();<br>
<br>
     &#x00A0;&#x00A0;private InfoFormatterFactory() {<br>
     &#x00A0;&#x00A0;}<br>
<br>
     &#x00A0;&#x00A0;public static InfoFormatterFactory getFactoryInstance() {<br>
         &#x00A0;&#x00A0;&#x00A0;&#x00A0;return FACTORY;<br>
     &#x00A0;&#x00A0;}<br>
<br>
     &#x00A0;&#x00A0;public static InfoFormatter getInstance(String key) {<br>
         &#x00A0;&#x00A0;&#x00A0;&#x00A0;return FACTORY.getEntity(key);<br>
     &#x00A0;&#x00A0;}<br>
<br>
     &#x00A0;&#x00A0;public static Collection&#x3C;InfoFormatter&#x3E; getAllInstances() {<br>
         &#x00A0;&#x00A0;&#x00A0;&#x00A0;return FACTORY.getAllEntities();<br>
     &#x00A0;&#x00A0;}<br>
 }<br>
 </code><br>
 </p>


 For the purposes of this infrastructure it is recommended that a single abstract parent class extending
 <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntity</code></a> and implementing your interface is created. Then all your concrete
 implementations will extend this class. So in our case we will have
 <a href="../../../../com/mgnt/lifecycle/management/example/BaseInfoFormatter.html" title="class in com.mgnt.lifecycle.management.example"><code>BaseInfoFormatter</code></a> that extends <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntity</code></a>
 and implements <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatter.html" title="interface in com.mgnt.lifecycle.management.example"><code>InfoFormatter</code></a>.
 This class should look like this:
 <p><br><code>

&nbsp;&nbsp; public abstract class BaseInfoFormatter extends BaseEntity&lt;BaseInfoFormatter&gt; implements InfoFormatter {<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; // This is mandatory part of the code for the infrastructure to work<br>
    &nbsp;&nbsp;&nbsp;&nbsp; private static final String FACTORY_TYPE = BaseInfoFormatter.class.getSimpleName();<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; static {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; init(FACTORY_TYPE, InfoFormatterFactory.getFactoryInstance());<br>
    &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; public BaseInfoFormatter() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(FACTORY_TYPE);<br>
    &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; public BaseInfoFormatter(String customName) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(FACTORY_TYPE, customName);<br>
    &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; // The end of mandatory part<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; // Some business logic methods that are common to all concrete implementations<br>
          &nbsp;&nbsp;&nbsp;&nbsp; //...<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; //Implementation of interface declared method<br>
          &nbsp;&nbsp;&nbsp;&nbsp; //...<br>
&nbsp;&nbsp; }<br>
<br></code></p>

 Then  we have 2 concrete implementations: <a href="../../../../com/mgnt/lifecycle/management/example/implementations/JsonInfoFormatter.html" title="class in com.mgnt.lifecycle.management.example.implementations"><code>JsonInfoFormatter</code></a>
 and <a href="../../../../com/mgnt/lifecycle/management/example/implementations/XmlInfoFormatter.html" title="class in com.mgnt.lifecycle.management.example.implementations"><code>XmlInfoFormatter</code></a> (both of them extending their abstract
 parent class <a href="../../../../com/mgnt/lifecycle/management/example/BaseInfoFormatter.html" title="class in com.mgnt.lifecycle.management.example"><code>BaseInfoFormatter</code></a>). Here is how one of them might look,
 (the second looks very similar so it is ommitted here)
 <p><br><code>
&nbsp;&nbsp; public class JsonInfoFormatter extends BaseInfoFormatter {<br>
    &nbsp;&nbsp;&nbsp;&nbsp; private final static String CUSTOM_NAME = "JSON";<br>
<br>
    &nbsp;&nbsp;&nbsp;&nbsp; public JsonInfoFormatter() {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(CUSTOM_NAME);<br>
    &nbsp;&nbsp;&nbsp;&nbsp; }<br>
<br>
 &nbsp;&nbsp;&nbsp;&nbsp;       //Implementation of abstract method or overriding methods goes here<br>
&nbsp;&nbsp; }<br>
<br></code></p>

 So this is our row material so to speak.
 So lets see how this is used. Look at the class
 <a href="../../../../com/mgnt/lifecycle/management/example/implementations/usage/UsageExample.html" title="class in com.mgnt.lifecycle.management.example.implementations.usage"><code>UsageExample</code></a> and in particular its methods
 <a href="../../../../com/mgnt/lifecycle/management/example/implementations/usage/UsageExample.html#init--"><code>UsageExample.init()</code></a> (that is invoked in the main()
 method) and looks as folllows
 <p><br><code>
    &nbsp;&nbsp; private static void init() { <br>
       &nbsp;&nbsp;&nbsp;&nbsp; new JsonInfoFormatter();<br>
       &nbsp;&nbsp;&nbsp;&nbsp; new XmlInfoFormatter();<br>
    &nbsp;&nbsp; }<br>
 </code>
 </p><br>
 and
 <a href="../../../../com/mgnt/lifecycle/management/example/implementations/usage/UsageExample.html#printFormattedGreetings--"><code>UsageExample.printFormattedGreetings()</code></a> that looks
 as follows
 <p><br><code>
    &nbsp;&nbsp; private static void printFormattedGreetings() { <br>
     &nbsp;&nbsp;&nbsp;&nbsp; InfoFormatter formatter = InfoFormatterFactory.getInstance("JSON"); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("JSON greeting: " + formatter.formatMessage(MESSAGE)); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; formatter = InfoFormatterFactory.getInstance("XML"); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("XML greeting: " + formatter.formatMessage(MESSAGE)); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; List&#x3C;String&#x3E; allMessages = new ArrayList&#x3C;&#x3E;(); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; for(InfoFormatter formattedMessage : InfoFormatterFactory.getAllInstances()) { <br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allMessages.add(formattedMessage.formatMessage(MESSAGE)); <br>
     &nbsp;&nbsp;&nbsp;&nbsp; } <br>
     &nbsp;&nbsp;&nbsp;&nbsp; System.out.println("All greetings: " + allMessages);<br>
  &nbsp;&nbsp; } <br>
 </code>
 </p>
 Note that we simply use <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatterFactory.html#getInstance-java.lang.String-"><code>getInstance(java.lang.String)</code></a>
 to get ahold of our concrete implementations. This works because method init was invoked before. Note that in init method
 we simply instantiate our concrete implementations and not saving any references to them. Thanks to the infrastructure,
 during its instantiation each instance inserted itself into its factory and that allows it to be accessed through the
 factory. As for the names ("XML" and "JSON") they are in our case defined in each concrete class and passed to the factory
 through use of its parent constructor
 <a href="../../../../com/mgnt/lifecycle/management/example/BaseInfoFormatter.html#BaseInfoFormatter-java.lang.String-"><code>BaseInfoFormatter.BaseInfoFormatter(java.lang.String)</code></a> which in turn will
 invoke its parent constructor <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html#BaseEntity-java.lang.String-java.lang.String-"><code>BaseEntity.BaseEntity(java.lang.String, java.lang.String)</code></a>.
 However, <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html" title="class in com.mgnt.lifecycle.management"><code>BaseEntity</code></a> provides another constructor
 <a href="../../../../com/mgnt/lifecycle/management/BaseEntity.html#BaseEntity-java.lang.String-"><code>BaseEntity.BaseEntity(java.lang.String)</code></a> where custom name for entity is not
 required. And the entity would be registered in its factory by its class name.
 <p>
     <br>
  That was about how this infrastructure works. Now where would it be convenient and beneficial to use it? Note that in order
  for infrastructure to work we had to invoke constructor for each concrete class. If only someone or something could
  have done that for us, that would be magical. Well, this could be done for us by Spring framework. Remember that Spring
  instantiate all it's defined beans during its initialization. So within Spring context if we simply declare our concrete
  implementations as Spring beans, Spring would instantiate them for us, thus initializing their factory automatically.
  This could be very convenient. Imagine that you have some bean that has a property of type
  <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatter.html" title="interface in com.mgnt.lifecycle.management.example"><code>InfoFormatter</code></a>, but which actual implementation would be needed is determined
  at runtime. So at that moment you can use
  <a href="../../../../com/mgnt/lifecycle/management/example/InfoFormatterFactory.html#getInstance-java.lang.String-"><code>getInstance(java.lang.String)</code></a> to access needed
  implementation. This will allow you not to inject ALL your concrete instantiations into your bean and you won't have to
  use Spring BeanFactory to access a Spring defined bean as that would violate non-intrusiveness of Spring (meaning 
  you can write components which have no dependency on Spring). Also, If at some later stage you will need to add
  more concrete implementations, all you will have to do is to add your implementation classes to you code and declare
  them to be Spring beans. The rest will be done by Spring and this infrastructure!
 </p></div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-use.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Package</li>
<li><a href="../../../../com/mgnt/lifecycle/management/backgroundrunner/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?com/mgnt/lifecycle/management/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
